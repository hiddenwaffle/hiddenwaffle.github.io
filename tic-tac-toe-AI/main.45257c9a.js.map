{"version":3,"sources":["../node_modules/roughjs/bin/core.js","../node_modules/roughjs/bin/geometry.js","../node_modules/roughjs/bin/path.js","../node_modules/roughjs/bin/fillers/scan-line-hachure.js","../node_modules/roughjs/bin/fillers/hachure-filler.js","../node_modules/roughjs/bin/fillers/zigzag-filler.js","../node_modules/roughjs/bin/fillers/hatch-filler.js","../node_modules/roughjs/bin/fillers/dot-filler.js","../node_modules/roughjs/bin/fillers/dashed-filler.js","../node_modules/roughjs/bin/fillers/zigzag-line-filler.js","../node_modules/roughjs/bin/fillers/filler.js","../node_modules/roughjs/bin/math.js","../node_modules/roughjs/bin/renderer.js","../node_modules/roughjs/bin/generator.js","../node_modules/roughjs/bin/canvas.js","../node_modules/roughjs/bin/svg.js","../node_modules/roughjs/bin/rough.js","elements.js","draw.js","main.js"],"names":["SVGNS","rotatePoints","points","center","degrees","length","cx","cy","angle","Math","PI","cos","sin","forEach","p","x","y","rotateLines","lines","line","push","lineLength","p1","p2","sqrt","pow","isType","token","type","PARAMS","A","a","C","c","H","h","L","l","M","m","Q","q","S","s","T","t","V","v","Z","z","ParsedPath","constructor","d","COMMAND","NUMBER","EOD","segments","parseData","processPoints","tokenize","tokens","Array","match","substr","RegExp","$1","text","parseFloat","index","mode","param_length","params","i","numbeToken","console","error","segment","key","data","closed","_closed","toLowerCase","first","currentPoint","point","RoughPath","_position","_first","bezierReflectionPoint","quadReflectionPoint","parsed","linearPoints","_linearPoints","lp","setPosition","position","RoughArcConverter","from","to","radii","largeArcFlag","sweepFlag","_segIndex","_numSegs","_rx","_ry","_sinPhi","_cosPhi","_C","_theta","_delta","_T","_from","radPerDeg","abs","x1dash","y1dash","root","numerator","cxdash","cydash","calculateVectorAngle","dtheta","ceil","getNextSegment","cosTheta1","sinTheta1","theta2","cosTheta2","sinTheta2","cp1","cp2","ux","uy","vx","vy","ta","atan2","tb","PathFitter","sets","fit","simplification","outSets","set","estLength","floor","reduce","count","slice","areas","minArea","minIndex","b","area","splice","polygonHachureLines","o","rotationCenter","round","hachureAngle","straightHachureLines","vertices","join","gap","hachureGap","strokeWidth","max","edges","ymin","min","ymax","islope","sort","e1","e2","activeEdges","ix","edge","filter","ae","ae1","ae2","nexti","ce","ne","HachureFiller","helper","fillPolygon","_fillPolygon","connectEnds","ops","renderLines","prevPoint","concat","doubleLineOps","ZigZagFiller","HatchFiller","o2","Object","assign","set2","DotFiller","curveStepCount","roughness","dotsOnLines","fweight","fillWeight","dl","alpha","atan","dy","dx","randOffsetWithRange","el","ellipse","DashedFiller","dashedLine","offset","dashOffset","dashGap","startOffset","lstart","lend","start","end","ZigZagLineFiller","zo","zigzagOffset","zigzagLines","dz","middle","fillers","getFiller","fillerName","fillStyle","randomSeed","random","Random","seed","next","imul","randOffset","x1","y1","x2","y2","_doubleLine","linearPath","close","len","polygon","rectangle","width","height","curve","o1","_curveWithOffset","ellipseWithParams","generateEllipseParams","opset","psq","stepCount","increment","rx","ry","curveFitRandomness","curveFitting","_offsetOpt","ellipseParams","ap1","_computeEllipsePoints","_offset","ap2","_curve","estimatedPoints","arc","stop","roughClosure","strt","stp","ellipseInc","arcInc","_arc","op","svgPath","path","replace","fitter","opList","_processSegment","solidFillPolygon","maxRandomnessOffset","patternFillPolygon","patternFillArc","randomizer","roughnessGain","_line","move","overlay","lengthSq","halfOffset","divergePoint","midDispX","bowing","midDispY","randomHalf","randomFull","ps","closePoint","curveTightness","cachedVertArray","ro","overlap","corePoints","allPoints","radOffset","_bezierTo","ros","f","seg","prevSeg","delta","ob","prevKey","ref","offset1","offset2","arcConverter","hasSelf","self","NOS","RoughGenerator","config","surface","defaultOptions","stroke","options","_options","newSeed","_drawable","shape","paths","outline","fill","ellipseResponse","circle","diameter","ret","size","computePathSize","document","svg","createElementNS","setAttribute","pathNode","appendChild","body","bb","getBBox","removeChild","err","canvasSize","getCanvasSize","val","w","baseVal","value","opsToPath","drawing","item","trim","toPaths","drawable","fillSketch","pattern","viewBox","patternUnits","hasDocument","RoughCanvas","canvas","ctx","getContext","gen","draw","getDefaultOptions","save","strokeStyle","lineWidth","_drawToContext","restore","p2d","Path2D","doc","ownerDocument","hcanvas","createElement","hcontext","bbox","computeBBox","translate","createPattern","beginPath","moveTo","bezierCurveTo","quadraticCurveTo","lineTo","generator","RoughSVG","defs","_defs","dnode","firstChild","insertBefore","window","g","style","id","Number","MAX_SAFE_INTEGER","patternPath","getElementById","winnerElement","resetElement","rc","rough","margin","drawGridLine","drawGrid","drawX","row","col","drawO","xmid","ymid","redraw","board","clearRect","serviceLocation","location","hostname","waitingForAi","winner","startWaitingForAi","classList","add","stopWaitingForAi","remove","handleWinner","given","message","textContent","advance","payload","fetch","method","headers","JSON","stringify","then","response","json","state","catch","e","finally","reset","addEventListener","rect","getBoundingClientRect","clientX","left","clientY","top"],"mappings":"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","file":"main.45257c9a.js","sourceRoot":"../js","sourcesContent":["export const SVGNS = 'http://www.w3.org/2000/svg';\n","export function rotatePoints(points, center, degrees) {\n    if (points && points.length) {\n        const [cx, cy] = center;\n        const angle = (Math.PI / 180) * degrees;\n        const cos = Math.cos(angle);\n        const sin = Math.sin(angle);\n        points.forEach((p) => {\n            const [x, y] = p;\n            p[0] = ((x - cx) * cos) - ((y - cy) * sin) + cx;\n            p[1] = ((x - cx) * sin) + ((y - cy) * cos) + cy;\n        });\n    }\n}\nexport function rotateLines(lines, center, degrees) {\n    const points = [];\n    lines.forEach((line) => points.push(...line));\n    rotatePoints(points, center, degrees);\n}\nexport function lineLength(line) {\n    const p1 = line[0];\n    const p2 = line[1];\n    return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));\n}\n","import { lineLength } from './geometry';\nfunction isType(token, type) {\n    return token.type === type;\n}\nconst PARAMS = {\n    A: 7,\n    a: 7,\n    C: 6,\n    c: 6,\n    H: 1,\n    h: 1,\n    L: 2,\n    l: 2,\n    M: 2,\n    m: 2,\n    Q: 4,\n    q: 4,\n    S: 4,\n    s: 4,\n    T: 4,\n    t: 2,\n    V: 1,\n    v: 1,\n    Z: 0,\n    z: 0\n};\nclass ParsedPath {\n    constructor(d) {\n        this.COMMAND = 0;\n        this.NUMBER = 1;\n        this.EOD = 2;\n        this.segments = [];\n        this.parseData(d);\n        this.processPoints();\n    }\n    tokenize(d) {\n        const tokens = new Array();\n        while (d !== '') {\n            if (d.match(/^([ \\t\\r\\n,]+)/)) {\n                d = d.substr(RegExp.$1.length);\n            }\n            else if (d.match(/^([aAcChHlLmMqQsStTvVzZ])/)) {\n                tokens[tokens.length] = { type: this.COMMAND, text: RegExp.$1 };\n                d = d.substr(RegExp.$1.length);\n            }\n            else if (d.match(/^(([-+]?[0-9]+(\\.[0-9]*)?|[-+]?\\.[0-9]+)([eE][-+]?[0-9]+)?)/)) {\n                tokens[tokens.length] = { type: this.NUMBER, text: `${parseFloat(RegExp.$1)}` };\n                d = d.substr(RegExp.$1.length);\n            }\n            else {\n                return [];\n            }\n        }\n        tokens[tokens.length] = { type: this.EOD, text: '' };\n        return tokens;\n    }\n    parseData(d) {\n        const tokens = this.tokenize(d);\n        let index = 0;\n        let token = tokens[index];\n        let mode = 'BOD';\n        this.segments = new Array();\n        while (!isType(token, this.EOD)) {\n            let param_length;\n            const params = new Array();\n            if (mode === 'BOD') {\n                if (token.text === 'M' || token.text === 'm') {\n                    index++;\n                    param_length = PARAMS[token.text];\n                    mode = token.text;\n                }\n                else {\n                    this.parseData('M0,0' + d);\n                    return;\n                }\n            }\n            else {\n                if (isType(token, this.NUMBER)) {\n                    param_length = PARAMS[mode];\n                }\n                else {\n                    index++;\n                    param_length = PARAMS[token.text];\n                    mode = token.text;\n                }\n            }\n            if ((index + param_length) < tokens.length) {\n                for (let i = index; i < index + param_length; i++) {\n                    const numbeToken = tokens[i];\n                    if (isType(numbeToken, this.NUMBER)) {\n                        params[params.length] = +numbeToken.text;\n                    }\n                    else {\n                        console.error('Param not a number: ' + mode + ',' + numbeToken.text);\n                        return;\n                    }\n                }\n                if (typeof PARAMS[mode] === 'number') {\n                    const segment = { key: mode, data: params };\n                    this.segments.push(segment);\n                    index += param_length;\n                    token = tokens[index];\n                    if (mode === 'M')\n                        mode = 'L';\n                    if (mode === 'm')\n                        mode = 'l';\n                }\n                else {\n                    console.error('Bad segment: ' + mode);\n                    return;\n                }\n            }\n            else {\n                console.error('Path data ended short');\n            }\n        }\n    }\n    get closed() {\n        if (typeof this._closed === 'undefined') {\n            this._closed = false;\n            for (const s of this.segments) {\n                if (s.key.toLowerCase() === 'z') {\n                    this._closed = true;\n                }\n            }\n        }\n        return this._closed;\n    }\n    processPoints() {\n        let first = null;\n        let currentPoint = [0, 0];\n        for (let i = 0; i < this.segments.length; i++) {\n            const s = this.segments[i];\n            switch (s.key) {\n                case 'M':\n                case 'L':\n                case 'T':\n                    s.point = [s.data[0], s.data[1]];\n                    break;\n                case 'm':\n                case 'l':\n                case 't':\n                    s.point = [s.data[0] + currentPoint[0], s.data[1] + currentPoint[1]];\n                    break;\n                case 'H':\n                    s.point = [s.data[0], currentPoint[1]];\n                    break;\n                case 'h':\n                    s.point = [s.data[0] + currentPoint[0], currentPoint[1]];\n                    break;\n                case 'V':\n                    s.point = [currentPoint[0], s.data[0]];\n                    break;\n                case 'v':\n                    s.point = [currentPoint[0], s.data[0] + currentPoint[1]];\n                    break;\n                case 'z':\n                case 'Z':\n                    if (first) {\n                        s.point = [first[0], first[1]];\n                    }\n                    break;\n                case 'C':\n                    s.point = [s.data[4], s.data[5]];\n                    break;\n                case 'c':\n                    s.point = [s.data[4] + currentPoint[0], s.data[5] + currentPoint[1]];\n                    break;\n                case 'S':\n                    s.point = [s.data[2], s.data[3]];\n                    break;\n                case 's':\n                    s.point = [s.data[2] + currentPoint[0], s.data[3] + currentPoint[1]];\n                    break;\n                case 'Q':\n                    s.point = [s.data[2], s.data[3]];\n                    break;\n                case 'q':\n                    s.point = [s.data[2] + currentPoint[0], s.data[3] + currentPoint[1]];\n                    break;\n                case 'A':\n                    s.point = [s.data[5], s.data[6]];\n                    break;\n                case 'a':\n                    s.point = [s.data[5] + currentPoint[0], s.data[6] + currentPoint[1]];\n                    break;\n            }\n            if (s.key === 'm' || s.key === 'M') {\n                first = null;\n            }\n            if (s.point) {\n                currentPoint = s.point;\n                if (!first) {\n                    first = s.point;\n                }\n            }\n            if (s.key === 'z' || s.key === 'Z') {\n                first = null;\n            }\n        }\n    }\n}\nexport class RoughPath {\n    constructor(d) {\n        this._position = [0, 0];\n        this._first = null;\n        this.bezierReflectionPoint = null;\n        this.quadReflectionPoint = null;\n        this.parsed = new ParsedPath(d);\n    }\n    get segments() {\n        return this.parsed.segments;\n    }\n    get closed() {\n        return this.parsed.closed;\n    }\n    get linearPoints() {\n        if (!this._linearPoints) {\n            const lp = [];\n            let points = [];\n            for (const s of this.parsed.segments) {\n                const key = s.key.toLowerCase();\n                if (key === 'm' || key === 'z') {\n                    if (points.length) {\n                        lp.push(points);\n                        points = [];\n                    }\n                    if (key === 'z') {\n                        continue;\n                    }\n                }\n                if (s.point) {\n                    points.push(s.point);\n                }\n            }\n            if (points.length) {\n                lp.push(points);\n                points = [];\n            }\n            this._linearPoints = lp;\n        }\n        return this._linearPoints;\n    }\n    get first() {\n        return this._first;\n    }\n    set first(v) {\n        this._first = v;\n    }\n    setPosition(x, y) {\n        this._position = [x, y];\n        if (!this._first) {\n            this._first = [x, y];\n        }\n    }\n    get position() {\n        return this._position;\n    }\n    get x() {\n        return this._position[0];\n    }\n    get y() {\n        return this._position[1];\n    }\n}\n// Algorithm as described in https://www.w3.org/TR/SVG/implnote.html\n// Code adapted from nsSVGPathDataParser.cpp in Mozilla \n// https://hg.mozilla.org/mozilla-central/file/17156fbebbc8/content/svg/content/src/nsSVGPathDataParser.cpp#l887\nexport class RoughArcConverter {\n    constructor(from, to, radii, angle, largeArcFlag, sweepFlag) {\n        this._segIndex = 0;\n        this._numSegs = 0;\n        this._rx = 0;\n        this._ry = 0;\n        this._sinPhi = 0;\n        this._cosPhi = 0;\n        this._C = [0, 0];\n        this._theta = 0;\n        this._delta = 0;\n        this._T = 0;\n        this._from = from;\n        if (from[0] === to[0] && from[1] === to[1]) {\n            return;\n        }\n        const radPerDeg = Math.PI / 180;\n        this._rx = Math.abs(radii[0]);\n        this._ry = Math.abs(radii[1]);\n        this._sinPhi = Math.sin(angle * radPerDeg);\n        this._cosPhi = Math.cos(angle * radPerDeg);\n        const x1dash = this._cosPhi * (from[0] - to[0]) / 2.0 + this._sinPhi * (from[1] - to[1]) / 2.0;\n        const y1dash = -this._sinPhi * (from[0] - to[0]) / 2.0 + this._cosPhi * (from[1] - to[1]) / 2.0;\n        let root = 0;\n        const numerator = this._rx * this._rx * this._ry * this._ry - this._rx * this._rx * y1dash * y1dash - this._ry * this._ry * x1dash * x1dash;\n        if (numerator < 0) {\n            const s = Math.sqrt(1 - (numerator / (this._rx * this._rx * this._ry * this._ry)));\n            this._rx = this._rx * s;\n            this._ry = this._ry * s;\n            root = 0;\n        }\n        else {\n            root = (largeArcFlag === sweepFlag ? -1.0 : 1.0) *\n                Math.sqrt(numerator / (this._rx * this._rx * y1dash * y1dash + this._ry * this._ry * x1dash * x1dash));\n        }\n        const cxdash = root * this._rx * y1dash / this._ry;\n        const cydash = -root * this._ry * x1dash / this._rx;\n        this._C = [0, 0];\n        this._C[0] = this._cosPhi * cxdash - this._sinPhi * cydash + (from[0] + to[0]) / 2.0;\n        this._C[1] = this._sinPhi * cxdash + this._cosPhi * cydash + (from[1] + to[1]) / 2.0;\n        this._theta = this.calculateVectorAngle(1.0, 0.0, (x1dash - cxdash) / this._rx, (y1dash - cydash) / this._ry);\n        let dtheta = this.calculateVectorAngle((x1dash - cxdash) / this._rx, (y1dash - cydash) / this._ry, (-x1dash - cxdash) / this._rx, (-y1dash - cydash) / this._ry);\n        if ((!sweepFlag) && (dtheta > 0)) {\n            dtheta -= 2 * Math.PI;\n        }\n        else if (sweepFlag && (dtheta < 0)) {\n            dtheta += 2 * Math.PI;\n        }\n        this._numSegs = Math.ceil(Math.abs(dtheta / (Math.PI / 2)));\n        this._delta = dtheta / this._numSegs;\n        this._T = (8 / 3) * Math.sin(this._delta / 4) * Math.sin(this._delta / 4) / Math.sin(this._delta / 2);\n    }\n    getNextSegment() {\n        if (this._segIndex === this._numSegs) {\n            return null;\n        }\n        const cosTheta1 = Math.cos(this._theta);\n        const sinTheta1 = Math.sin(this._theta);\n        const theta2 = this._theta + this._delta;\n        const cosTheta2 = Math.cos(theta2);\n        const sinTheta2 = Math.sin(theta2);\n        const to = [\n            this._cosPhi * this._rx * cosTheta2 - this._sinPhi * this._ry * sinTheta2 + this._C[0],\n            this._sinPhi * this._rx * cosTheta2 + this._cosPhi * this._ry * sinTheta2 + this._C[1]\n        ];\n        const cp1 = [\n            this._from[0] + this._T * (-this._cosPhi * this._rx * sinTheta1 - this._sinPhi * this._ry * cosTheta1),\n            this._from[1] + this._T * (-this._sinPhi * this._rx * sinTheta1 + this._cosPhi * this._ry * cosTheta1)\n        ];\n        const cp2 = [\n            to[0] + this._T * (this._cosPhi * this._rx * sinTheta2 + this._sinPhi * this._ry * cosTheta2),\n            to[1] + this._T * (this._sinPhi * this._rx * sinTheta2 - this._cosPhi * this._ry * cosTheta2)\n        ];\n        this._theta = theta2;\n        this._from = [to[0], to[1]];\n        this._segIndex++;\n        return {\n            cp1: cp1,\n            cp2: cp2,\n            to: to\n        };\n    }\n    calculateVectorAngle(ux, uy, vx, vy) {\n        const ta = Math.atan2(uy, ux);\n        const tb = Math.atan2(vy, vx);\n        if (tb >= ta)\n            return tb - ta;\n        return 2 * Math.PI - (ta - tb);\n    }\n}\nexport class PathFitter {\n    constructor(sets, closed) {\n        this.sets = sets;\n        this.closed = closed;\n    }\n    fit(simplification) {\n        const outSets = [];\n        for (const set of this.sets) {\n            const length = set.length;\n            let estLength = Math.floor(simplification * length);\n            if (estLength < 5) {\n                if (length <= 5) {\n                    continue;\n                }\n                estLength = 5;\n            }\n            outSets.push(this.reduce(set, estLength));\n        }\n        let d = '';\n        for (const set of outSets) {\n            for (let i = 0; i < set.length; i++) {\n                const point = set[i];\n                if (i === 0) {\n                    d += 'M' + point[0] + ',' + point[1];\n                }\n                else {\n                    d += 'L' + point[0] + ',' + point[1];\n                }\n            }\n            if (this.closed) {\n                d += 'z ';\n            }\n        }\n        return d;\n    }\n    reduce(set, count) {\n        if (set.length <= count) {\n            return set;\n        }\n        const points = set.slice(0);\n        while (points.length > count) {\n            const areas = [];\n            let minArea = -1;\n            let minIndex = -1;\n            for (let i = 1; i < (points.length - 1); i++) {\n                const a = lineLength([points[i - 1], points[i]]);\n                const b = lineLength([points[i], points[i + 1]]);\n                const c = lineLength([points[i - 1], points[i + 1]]);\n                const s = (a + b + c) / 2.0;\n                const area = Math.sqrt(s * (s - a) * (s - b) * (s - c));\n                areas.push(area);\n                if ((minArea < 0) || (area < minArea)) {\n                    minArea = area;\n                    minIndex = i;\n                }\n            }\n            if (minIndex > 0) {\n                points.splice(minIndex, 1);\n            }\n            else {\n                break;\n            }\n        }\n        return points;\n    }\n}\n","import { rotatePoints, rotateLines } from '../geometry';\nexport function polygonHachureLines(points, o) {\n    const rotationCenter = [0, 0];\n    const angle = Math.round(o.hachureAngle + 90);\n    if (angle) {\n        rotatePoints(points, rotationCenter, angle);\n    }\n    const lines = straightHachureLines(points, o);\n    if (angle) {\n        rotatePoints(points, rotationCenter, -angle);\n        rotateLines(lines, rotationCenter, -angle);\n    }\n    return lines;\n}\nfunction straightHachureLines(points, o) {\n    const vertices = [...points];\n    if (vertices[0].join(',') !== vertices[vertices.length - 1].join(',')) {\n        vertices.push([vertices[0][0], vertices[0][1]]);\n    }\n    const lines = [];\n    if (vertices && vertices.length > 2) {\n        let gap = o.hachureGap;\n        if (gap < 0) {\n            gap = o.strokeWidth * 4;\n        }\n        gap = Math.max(gap, 0.1);\n        // Create sorted edges table\n        const edges = [];\n        for (let i = 0; i < vertices.length - 1; i++) {\n            const p1 = vertices[i];\n            const p2 = vertices[i + 1];\n            if (p1[1] !== p2[1]) {\n                const ymin = Math.min(p1[1], p2[1]);\n                edges.push({\n                    ymin,\n                    ymax: Math.max(p1[1], p2[1]),\n                    x: ymin === p1[1] ? p1[0] : p2[0],\n                    islope: (p2[0] - p1[0]) / (p2[1] - p1[1])\n                });\n            }\n        }\n        edges.sort((e1, e2) => {\n            if (e1.ymin < e2.ymin) {\n                return -1;\n            }\n            if (e1.ymin > e2.ymin) {\n                return 1;\n            }\n            if (e1.x < e2.x) {\n                return -1;\n            }\n            if (e1.x > e2.x) {\n                return 1;\n            }\n            if (e1.ymax === e2.ymax) {\n                return 0;\n            }\n            return (e1.ymax - e2.ymax) / Math.abs((e1.ymax - e2.ymax));\n        });\n        if (!edges.length) {\n            return lines;\n        }\n        // Start scanning\n        let activeEdges = [];\n        let y = edges[0].ymin;\n        while (activeEdges.length || edges.length) {\n            if (edges.length) {\n                let ix = -1;\n                for (let i = 0; i < edges.length; i++) {\n                    if (edges[i].ymin > y) {\n                        break;\n                    }\n                    ix = i;\n                }\n                const removed = edges.splice(0, ix + 1);\n                removed.forEach((edge) => {\n                    activeEdges.push({ s: y, edge });\n                });\n            }\n            activeEdges = activeEdges.filter((ae) => {\n                if (ae.edge.ymax <= y) {\n                    return false;\n                }\n                return true;\n            });\n            activeEdges.sort((ae1, ae2) => {\n                if (ae1.edge.x === ae2.edge.x) {\n                    return 0;\n                }\n                return (ae1.edge.x - ae2.edge.x) / Math.abs((ae1.edge.x - ae2.edge.x));\n            });\n            // fill between the edges\n            if (activeEdges.length > 1) {\n                for (let i = 0; i < activeEdges.length; i = i + 2) {\n                    const nexti = i + 1;\n                    if (nexti >= activeEdges.length) {\n                        break;\n                    }\n                    const ce = activeEdges[i].edge;\n                    const ne = activeEdges[nexti].edge;\n                    lines.push([\n                        [Math.round(ce.x), y],\n                        [Math.round(ne.x), y]\n                    ]);\n                }\n            }\n            y += gap;\n            activeEdges.forEach((ae) => {\n                ae.edge.x = ae.edge.x + (gap * ae.edge.islope);\n            });\n        }\n    }\n    return lines;\n}\n","import { polygonHachureLines } from './scan-line-hachure';\nexport class HachureFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygon(points, o) {\n        return this._fillPolygon(points, o);\n    }\n    _fillPolygon(points, o, connectEnds = false) {\n        const lines = polygonHachureLines(points, o);\n        const ops = this.renderLines(lines, o, connectEnds);\n        return { type: 'fillSketch', ops };\n    }\n    renderLines(lines, o, connectEnds) {\n        let ops = [];\n        let prevPoint = null;\n        for (const line of lines) {\n            ops = ops.concat(this.helper.doubleLineOps(line[0][0], line[0][1], line[1][0], line[1][1], o));\n            if (connectEnds && prevPoint) {\n                ops = ops.concat(this.helper.doubleLineOps(prevPoint[0], prevPoint[1], line[0][0], line[0][1], o));\n            }\n            prevPoint = line[1];\n        }\n        return ops;\n    }\n}\n","import { HachureFiller } from './hachure-filler';\nexport class ZigZagFiller extends HachureFiller {\n    fillPolygon(points, o) {\n        return this._fillPolygon(points, o, true);\n    }\n}\n","import { HachureFiller } from './hachure-filler';\nexport class HatchFiller extends HachureFiller {\n    fillPolygon(points, o) {\n        const set = this._fillPolygon(points, o);\n        const o2 = Object.assign({}, o, { hachureAngle: o.hachureAngle + 90 });\n        const set2 = this._fillPolygon(points, o2);\n        set.ops = set.ops.concat(set2.ops);\n        return set;\n    }\n}\n","import { lineLength } from '../geometry';\nimport { polygonHachureLines } from './scan-line-hachure';\nexport class DotFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygon(points, o) {\n        o = Object.assign({}, o, { curveStepCount: 4, hachureAngle: 0, roughness: 1 });\n        const lines = polygonHachureLines(points, o);\n        return this.dotsOnLines(lines, o);\n    }\n    dotsOnLines(lines, o) {\n        let ops = [];\n        let gap = o.hachureGap;\n        if (gap < 0) {\n            gap = o.strokeWidth * 4;\n        }\n        gap = Math.max(gap, 0.1);\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        for (const line of lines) {\n            const length = lineLength(line);\n            const dl = length / gap;\n            const count = Math.ceil(dl) - 1;\n            const alpha = Math.atan((line[1][1] - line[0][1]) / (line[1][0] - line[0][0]));\n            for (let i = 0; i < count; i++) {\n                const l = gap * (i + 1);\n                const dy = l * Math.sin(alpha);\n                const dx = l * Math.cos(alpha);\n                const c = [line[0][0] - dx, line[0][1] + dy];\n                const cx = this.helper.randOffsetWithRange(c[0] - gap / 4, c[0] + gap / 4, o);\n                const cy = this.helper.randOffsetWithRange(c[1] - gap / 4, c[1] + gap / 4, o);\n                const el = this.helper.ellipse(cx, cy, fweight, fweight, o);\n                ops = ops.concat(el.ops);\n            }\n        }\n        return { type: 'fillSketch', ops };\n    }\n}\n","import { lineLength } from '../geometry';\nimport { polygonHachureLines } from './scan-line-hachure';\nexport class DashedFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygon(points, o) {\n        const lines = polygonHachureLines(points, o);\n        return { type: 'fillSketch', ops: this.dashedLine(lines, o) };\n    }\n    dashedLine(lines, o) {\n        const offset = o.dashOffset < 0 ? (o.hachureGap < 0 ? (o.strokeWidth * 4) : o.hachureGap) : o.dashOffset;\n        const gap = o.dashGap < 0 ? (o.hachureGap < 0 ? (o.strokeWidth * 4) : o.hachureGap) : o.dashGap;\n        let ops = [];\n        lines.forEach((line) => {\n            const length = lineLength(line);\n            const count = Math.floor(length / (offset + gap));\n            const startOffset = (length + gap - (count * (offset + gap))) / 2;\n            let p1 = line[0];\n            let p2 = line[1];\n            if (p1[0] > p2[0]) {\n                p1 = line[1];\n                p2 = line[0];\n            }\n            const alpha = Math.atan((p2[1] - p1[1]) / (p2[0] - p1[0]));\n            for (let i = 0; i < count; i++) {\n                const lstart = i * (offset + gap);\n                const lend = lstart + offset;\n                const start = [p1[0] + (lstart * Math.cos(alpha)) + (startOffset * Math.cos(alpha)), p1[1] + lstart * Math.sin(alpha) + (startOffset * Math.sin(alpha))];\n                const end = [p1[0] + (lend * Math.cos(alpha)) + (startOffset * Math.cos(alpha)), p1[1] + (lend * Math.sin(alpha)) + (startOffset * Math.sin(alpha))];\n                ops = ops.concat(this.helper.doubleLineOps(start[0], start[1], end[0], end[1], o));\n            }\n        });\n        return ops;\n    }\n}\n","import { lineLength } from '../geometry';\nimport { polygonHachureLines } from './scan-line-hachure';\nexport class ZigZagLineFiller {\n    constructor(helper) {\n        this.helper = helper;\n    }\n    fillPolygon(points, o) {\n        const gap = o.hachureGap < 0 ? (o.strokeWidth * 4) : o.hachureGap;\n        const zo = o.zigzagOffset < 0 ? gap : o.zigzagOffset;\n        o = Object.assign({}, o, { hachureGap: gap + zo });\n        const lines = polygonHachureLines(points, o);\n        return { type: 'fillSketch', ops: this.zigzagLines(lines, zo, o) };\n    }\n    zigzagLines(lines, zo, o) {\n        let ops = [];\n        lines.forEach((line) => {\n            const length = lineLength(line);\n            const count = Math.round(length / (2 * zo));\n            let p1 = line[0];\n            let p2 = line[1];\n            if (p1[0] > p2[0]) {\n                p1 = line[1];\n                p2 = line[0];\n            }\n            const alpha = Math.atan((p2[1] - p1[1]) / (p2[0] - p1[0]));\n            for (let i = 0; i < count; i++) {\n                const lstart = i * 2 * zo;\n                const lend = (i + 1) * 2 * zo;\n                const dz = Math.sqrt(2 * Math.pow(zo, 2));\n                const start = [p1[0] + (lstart * Math.cos(alpha)), p1[1] + lstart * Math.sin(alpha)];\n                const end = [p1[0] + (lend * Math.cos(alpha)), p1[1] + (lend * Math.sin(alpha))];\n                const middle = [start[0] + dz * Math.cos(alpha + Math.PI / 4), start[1] + dz * Math.sin(alpha + Math.PI / 4)];\n                ops = ops.concat(this.helper.doubleLineOps(start[0], start[1], middle[0], middle[1], o));\n                ops = ops.concat(this.helper.doubleLineOps(middle[0], middle[1], end[0], end[1], o));\n            }\n        });\n        return ops;\n    }\n}\n","import { HachureFiller } from './hachure-filler';\nimport { ZigZagFiller } from './zigzag-filler';\nimport { HatchFiller } from './hatch-filler';\nimport { DotFiller } from './dot-filler';\nimport { DashedFiller } from './dashed-filler';\nimport { ZigZagLineFiller } from './zigzag-line-filler';\nconst fillers = {};\nexport function getFiller(o, helper) {\n    let fillerName = o.fillStyle || 'hachure';\n    if (!fillers[fillerName]) {\n        switch (fillerName) {\n            case 'zigzag':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new ZigZagFiller(helper);\n                }\n                break;\n            case 'cross-hatch':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new HatchFiller(helper);\n                }\n                break;\n            case 'dots':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new DotFiller(helper);\n                }\n                break;\n            case 'dashed':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new DashedFiller(helper);\n                }\n                break;\n            case 'zigzag-line':\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new ZigZagLineFiller(helper);\n                }\n                break;\n            case 'hachure':\n            default:\n                fillerName = 'hachure';\n                if (!fillers[fillerName]) {\n                    fillers[fillerName] = new HachureFiller(helper);\n                }\n                break;\n        }\n    }\n    return fillers[fillerName];\n}\n","export function randomSeed() {\n    return Math.floor(Math.random() * 2 ** 31);\n}\nexport class Random {\n    constructor(seed) {\n        this.seed = seed;\n    }\n    next() {\n        if (this.seed) {\n            return ((2 ** 31 - 1) & (this.seed = Math.imul(48271, this.seed))) / 2 ** 31;\n        }\n        else {\n            return Math.random();\n        }\n    }\n}\n","import { RoughPath, PathFitter, RoughArcConverter } from './path.js';\nimport { getFiller } from './fillers/filler.js';\nimport { Random } from './math.js';\nconst helper = {\n    randOffset,\n    randOffsetWithRange,\n    ellipse,\n    doubleLineOps\n};\nexport function line(x1, y1, x2, y2, o) {\n    return { type: 'path', ops: _doubleLine(x1, y1, x2, y2, o) };\n}\nexport function linearPath(points, close, o) {\n    const len = (points || []).length;\n    if (len > 2) {\n        let ops = [];\n        for (let i = 0; i < (len - 1); i++) {\n            ops = ops.concat(_doubleLine(points[i][0], points[i][1], points[i + 1][0], points[i + 1][1], o));\n        }\n        if (close) {\n            ops = ops.concat(_doubleLine(points[len - 1][0], points[len - 1][1], points[0][0], points[0][1], o));\n        }\n        return { type: 'path', ops };\n    }\n    else if (len === 2) {\n        return line(points[0][0], points[0][1], points[1][0], points[1][1], o);\n    }\n    return { type: 'path', ops: [] };\n}\nexport function polygon(points, o) {\n    return linearPath(points, true, o);\n}\nexport function rectangle(x, y, width, height, o) {\n    const points = [\n        [x, y], [x + width, y], [x + width, y + height], [x, y + height]\n    ];\n    return polygon(points, o);\n}\nexport function curve(points, o) {\n    const o1 = _curveWithOffset(points, 1 * (1 + o.roughness * 0.2), o);\n    const o2 = _curveWithOffset(points, 1.5 * (1 + o.roughness * 0.22), o);\n    return { type: 'path', ops: o1.concat(o2) };\n}\nexport function ellipse(x, y, width, height, o) {\n    const params = generateEllipseParams(width, height, o);\n    return ellipseWithParams(x, y, o, params).opset;\n}\nexport function generateEllipseParams(width, height, o) {\n    const psq = Math.sqrt(Math.PI * 2 * Math.sqrt((Math.pow(width / 2, 2) + Math.pow(height / 2, 2)) / 2));\n    const stepCount = Math.max(o.curveStepCount, (o.curveStepCount / Math.sqrt(200)) * psq);\n    const increment = (Math.PI * 2) / stepCount;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    const curveFitRandomness = 1 - o.curveFitting;\n    rx += _offsetOpt(rx * curveFitRandomness, o);\n    ry += _offsetOpt(ry * curveFitRandomness, o);\n    return { increment, rx, ry };\n}\nexport function ellipseWithParams(x, y, o, ellipseParams) {\n    const [ap1, cp1] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1, ellipseParams.increment * _offset(0.1, _offset(0.4, 1, o), o), o);\n    const [ap2] = _computeEllipsePoints(ellipseParams.increment, x, y, ellipseParams.rx, ellipseParams.ry, 1.5, 0, o);\n    const o1 = _curve(ap1, null, o);\n    const o2 = _curve(ap2, null, o);\n    return {\n        estimatedPoints: cp1,\n        opset: { type: 'path', ops: o1.concat(o2) }\n    };\n}\nexport function arc(x, y, width, height, start, stop, closed, roughClosure, o) {\n    const cx = x;\n    const cy = y;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += _offsetOpt(rx * 0.01, o);\n    ry += _offsetOpt(ry * 0.01, o);\n    let strt = start;\n    let stp = stop;\n    while (strt < 0) {\n        strt += Math.PI * 2;\n        stp += Math.PI * 2;\n    }\n    if ((stp - strt) > (Math.PI * 2)) {\n        strt = 0;\n        stp = Math.PI * 2;\n    }\n    const ellipseInc = (Math.PI * 2) / o.curveStepCount;\n    const arcInc = Math.min(ellipseInc / 2, (stp - strt) / 2);\n    const o1 = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1, o);\n    const o2 = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1.5, o);\n    let ops = o1.concat(o2);\n    if (closed) {\n        if (roughClosure) {\n            ops = ops.concat(_doubleLine(cx, cy, cx + rx * Math.cos(strt), cy + ry * Math.sin(strt), o));\n            ops = ops.concat(_doubleLine(cx, cy, cx + rx * Math.cos(stp), cy + ry * Math.sin(stp), o));\n        }\n        else {\n            ops.push({ op: 'lineTo', data: [cx, cy] });\n            ops.push({ op: 'lineTo', data: [cx + rx * Math.cos(strt), cy + ry * Math.sin(strt)] });\n        }\n    }\n    return { type: 'path', ops };\n}\nexport function svgPath(path, o) {\n    path = (path || '').replace(/\\n/g, ' ').replace(/(-\\s)/g, '-').replace('/(\\s\\s)/g', ' ');\n    let p = new RoughPath(path);\n    if (o.simplification) {\n        const fitter = new PathFitter(p.linearPoints, p.closed);\n        const d = fitter.fit(o.simplification);\n        p = new RoughPath(d);\n    }\n    let ops = [];\n    const segments = p.segments || [];\n    for (let i = 0; i < segments.length; i++) {\n        const s = segments[i];\n        const prev = i > 0 ? segments[i - 1] : null;\n        const opList = _processSegment(p, s, prev, o);\n        if (opList && opList.length) {\n            ops = ops.concat(opList);\n        }\n    }\n    return { type: 'path', ops };\n}\n// Fills\nexport function solidFillPolygon(points, o) {\n    const ops = [];\n    if (points.length) {\n        const offset = o.maxRandomnessOffset || 0;\n        const len = points.length;\n        if (len > 2) {\n            ops.push({ op: 'move', data: [points[0][0] + _offsetOpt(offset, o), points[0][1] + _offsetOpt(offset, o)] });\n            for (let i = 1; i < len; i++) {\n                ops.push({ op: 'lineTo', data: [points[i][0] + _offsetOpt(offset, o), points[i][1] + _offsetOpt(offset, o)] });\n            }\n        }\n    }\n    return { type: 'fillPath', ops };\n}\nexport function patternFillPolygon(points, o) {\n    return getFiller(o, helper).fillPolygon(points, o);\n}\nexport function patternFillArc(x, y, width, height, start, stop, o) {\n    const cx = x;\n    const cy = y;\n    let rx = Math.abs(width / 2);\n    let ry = Math.abs(height / 2);\n    rx += _offsetOpt(rx * 0.01, o);\n    ry += _offsetOpt(ry * 0.01, o);\n    let strt = start;\n    let stp = stop;\n    while (strt < 0) {\n        strt += Math.PI * 2;\n        stp += Math.PI * 2;\n    }\n    if ((stp - strt) > (Math.PI * 2)) {\n        strt = 0;\n        stp = Math.PI * 2;\n    }\n    const increment = (stp - strt) / o.curveStepCount;\n    const points = [];\n    for (let angle = strt; angle <= stp; angle = angle + increment) {\n        points.push([cx + rx * Math.cos(angle), cy + ry * Math.sin(angle)]);\n    }\n    points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);\n    points.push([cx, cy]);\n    return patternFillPolygon(points, o);\n}\nexport function randOffset(x, o) {\n    return _offsetOpt(x, o);\n}\nexport function randOffsetWithRange(min, max, o) {\n    return _offset(min, max, o);\n}\nexport function doubleLineOps(x1, y1, x2, y2, o) {\n    return _doubleLine(x1, y1, x2, y2, o);\n}\n// Private helpers\nfunction random(ops) {\n    if (!ops.randomizer) {\n        ops.randomizer = new Random(ops.seed || 0);\n    }\n    return ops.randomizer.next();\n}\nfunction _offset(min, max, ops) {\n    return ops.roughness * ops.roughnessGain * ((random(ops) * (max - min)) + min);\n}\nfunction _offsetOpt(x, ops) {\n    return _offset(-x, x, ops);\n}\nfunction _doubleLine(x1, y1, x2, y2, o) {\n    const o1 = _line(x1, y1, x2, y2, o, true, false);\n    const o2 = _line(x1, y1, x2, y2, o, true, true);\n    return o1.concat(o2);\n}\nfunction _line(x1, y1, x2, y2, o, move, overlay) {\n    const lengthSq = Math.pow((x1 - x2), 2) + Math.pow((y1 - y2), 2);\n    const length = Math.sqrt(lengthSq);\n    if (length < 200) {\n        o.roughnessGain = 1;\n    }\n    else if (length > 500) {\n        o.roughnessGain = 0.4;\n    }\n    else {\n        o.roughnessGain = (-0.0016668) * length + 1.233334;\n    }\n    let offset = o.maxRandomnessOffset || 0;\n    if ((offset * offset * 100) > lengthSq) {\n        offset = length / 10;\n    }\n    const halfOffset = offset / 2;\n    const divergePoint = 0.2 + random(o) * 0.2;\n    let midDispX = o.bowing * o.maxRandomnessOffset * (y2 - y1) / 200;\n    let midDispY = o.bowing * o.maxRandomnessOffset * (x1 - x2) / 200;\n    midDispX = _offsetOpt(midDispX, o);\n    midDispY = _offsetOpt(midDispY, o);\n    const ops = [];\n    const randomHalf = () => _offsetOpt(halfOffset, o);\n    const randomFull = () => _offsetOpt(offset, o);\n    if (move) {\n        if (overlay) {\n            ops.push({\n                op: 'move', data: [\n                    x1 + randomHalf(),\n                    y1 + randomHalf()\n                ]\n            });\n        }\n        else {\n            ops.push({\n                op: 'move', data: [\n                    x1 + _offsetOpt(offset, o),\n                    y1 + _offsetOpt(offset, o)\n                ]\n            });\n        }\n    }\n    if (overlay) {\n        ops.push({\n            op: 'bcurveTo', data: [\n                midDispX + x1 + (x2 - x1) * divergePoint + randomHalf(),\n                midDispY + y1 + (y2 - y1) * divergePoint + randomHalf(),\n                midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomHalf(),\n                midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomHalf(),\n                x2 + randomHalf(),\n                y2 + randomHalf()\n            ]\n        });\n    }\n    else {\n        ops.push({\n            op: 'bcurveTo', data: [\n                midDispX + x1 + (x2 - x1) * divergePoint + randomFull(),\n                midDispY + y1 + (y2 - y1) * divergePoint + randomFull(),\n                midDispX + x1 + 2 * (x2 - x1) * divergePoint + randomFull(),\n                midDispY + y1 + 2 * (y2 - y1) * divergePoint + randomFull(),\n                x2 + randomFull(),\n                y2 + randomFull()\n            ]\n        });\n    }\n    return ops;\n}\nfunction _curveWithOffset(points, offset, o) {\n    const ps = [];\n    ps.push([\n        points[0][0] + _offsetOpt(offset, o),\n        points[0][1] + _offsetOpt(offset, o),\n    ]);\n    ps.push([\n        points[0][0] + _offsetOpt(offset, o),\n        points[0][1] + _offsetOpt(offset, o),\n    ]);\n    for (let i = 1; i < points.length; i++) {\n        ps.push([\n            points[i][0] + _offsetOpt(offset, o),\n            points[i][1] + _offsetOpt(offset, o),\n        ]);\n        if (i === (points.length - 1)) {\n            ps.push([\n                points[i][0] + _offsetOpt(offset, o),\n                points[i][1] + _offsetOpt(offset, o),\n            ]);\n        }\n    }\n    return _curve(ps, null, o);\n}\nfunction _curve(points, closePoint, o) {\n    const len = points.length;\n    let ops = [];\n    if (len > 3) {\n        const b = [];\n        const s = 1 - o.curveTightness;\n        ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n        for (let i = 1; (i + 2) < len; i++) {\n            const cachedVertArray = points[i];\n            b[0] = [cachedVertArray[0], cachedVertArray[1]];\n            b[1] = [cachedVertArray[0] + (s * points[i + 1][0] - s * points[i - 1][0]) / 6, cachedVertArray[1] + (s * points[i + 1][1] - s * points[i - 1][1]) / 6];\n            b[2] = [points[i + 1][0] + (s * points[i][0] - s * points[i + 2][0]) / 6, points[i + 1][1] + (s * points[i][1] - s * points[i + 2][1]) / 6];\n            b[3] = [points[i + 1][0], points[i + 1][1]];\n            ops.push({ op: 'bcurveTo', data: [b[1][0], b[1][1], b[2][0], b[2][1], b[3][0], b[3][1]] });\n        }\n        if (closePoint && closePoint.length === 2) {\n            const ro = o.maxRandomnessOffset;\n            ops.push({ op: 'lineTo', data: [closePoint[0] + _offsetOpt(ro, o), closePoint[1] + _offsetOpt(ro, o)] });\n        }\n    }\n    else if (len === 3) {\n        ops.push({ op: 'move', data: [points[1][0], points[1][1]] });\n        ops.push({\n            op: 'bcurveTo', data: [\n                points[1][0], points[1][1],\n                points[2][0], points[2][1],\n                points[2][0], points[2][1]\n            ]\n        });\n    }\n    else if (len === 2) {\n        ops = ops.concat(_doubleLine(points[0][0], points[0][1], points[1][0], points[1][1], o));\n    }\n    return ops;\n}\nfunction _computeEllipsePoints(increment, cx, cy, rx, ry, offset, overlap, o) {\n    const corePoints = [];\n    const allPoints = [];\n    const radOffset = _offsetOpt(0.5, o) - (Math.PI / 2);\n    allPoints.push([\n        _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n        _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment)\n    ]);\n    for (let angle = radOffset; angle < (Math.PI * 2 + radOffset - 0.01); angle = angle + increment) {\n        const p = [\n            _offsetOpt(offset, o) + cx + rx * Math.cos(angle),\n            _offsetOpt(offset, o) + cy + ry * Math.sin(angle)\n        ];\n        corePoints.push(p);\n        allPoints.push(p);\n    }\n    allPoints.push([\n        _offsetOpt(offset, o) + cx + rx * Math.cos(radOffset + Math.PI * 2 + overlap * 0.5),\n        _offsetOpt(offset, o) + cy + ry * Math.sin(radOffset + Math.PI * 2 + overlap * 0.5)\n    ]);\n    allPoints.push([\n        _offsetOpt(offset, o) + cx + 0.98 * rx * Math.cos(radOffset + overlap),\n        _offsetOpt(offset, o) + cy + 0.98 * ry * Math.sin(radOffset + overlap)\n    ]);\n    allPoints.push([\n        _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset + overlap * 0.5),\n        _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset + overlap * 0.5)\n    ]);\n    return [allPoints, corePoints];\n}\nfunction _arc(increment, cx, cy, rx, ry, strt, stp, offset, o) {\n    const radOffset = strt + _offsetOpt(0.1, o);\n    const points = [];\n    points.push([\n        _offsetOpt(offset, o) + cx + 0.9 * rx * Math.cos(radOffset - increment),\n        _offsetOpt(offset, o) + cy + 0.9 * ry * Math.sin(radOffset - increment)\n    ]);\n    for (let angle = radOffset; angle <= stp; angle = angle + increment) {\n        points.push([\n            _offsetOpt(offset, o) + cx + rx * Math.cos(angle),\n            _offsetOpt(offset, o) + cy + ry * Math.sin(angle)\n        ]);\n    }\n    points.push([\n        cx + rx * Math.cos(stp),\n        cy + ry * Math.sin(stp)\n    ]);\n    points.push([\n        cx + rx * Math.cos(stp),\n        cy + ry * Math.sin(stp)\n    ]);\n    return _curve(points, null, o);\n}\nfunction _bezierTo(x1, y1, x2, y2, x, y, path, o) {\n    const ops = [];\n    const ros = [o.maxRandomnessOffset || 1, (o.maxRandomnessOffset || 1) + 0.5];\n    let f = [0, 0];\n    for (let i = 0; i < 2; i++) {\n        if (i === 0) {\n            ops.push({ op: 'move', data: [path.x, path.y] });\n        }\n        else {\n            ops.push({ op: 'move', data: [path.x + _offsetOpt(ros[0], o), path.y + _offsetOpt(ros[0], o)] });\n        }\n        f = [x + _offsetOpt(ros[i], o), y + _offsetOpt(ros[i], o)];\n        ops.push({\n            op: 'bcurveTo', data: [\n                x1 + _offsetOpt(ros[i], o), y1 + _offsetOpt(ros[i], o),\n                x2 + _offsetOpt(ros[i], o), y2 + _offsetOpt(ros[i], o),\n                f[0], f[1]\n            ]\n        });\n    }\n    path.setPosition(f[0], f[1]);\n    return ops;\n}\nfunction _processSegment(path, seg, prevSeg, o) {\n    let ops = [];\n    switch (seg.key) {\n        case 'M':\n        case 'm': {\n            const delta = seg.key === 'm';\n            if (seg.data.length >= 2) {\n                let x = +seg.data[0];\n                let y = +seg.data[1];\n                if (delta) {\n                    x += path.x;\n                    y += path.y;\n                }\n                const ro = 1 * (o.maxRandomnessOffset || 0);\n                x = x + _offsetOpt(ro, o);\n                y = y + _offsetOpt(ro, o);\n                path.setPosition(x, y);\n                ops.push({ op: 'move', data: [x, y] });\n            }\n            break;\n        }\n        case 'L':\n        case 'l': {\n            const delta = seg.key === 'l';\n            if (seg.data.length >= 2) {\n                let x = +seg.data[0];\n                let y = +seg.data[1];\n                if (delta) {\n                    x += path.x;\n                    y += path.y;\n                }\n                ops = ops.concat(_doubleLine(path.x, path.y, x, y, o));\n                path.setPosition(x, y);\n            }\n            break;\n        }\n        case 'H':\n        case 'h': {\n            const delta = seg.key === 'h';\n            if (seg.data.length) {\n                let x = +seg.data[0];\n                if (delta) {\n                    x += path.x;\n                }\n                ops = ops.concat(_doubleLine(path.x, path.y, x, path.y, o));\n                path.setPosition(x, path.y);\n            }\n            break;\n        }\n        case 'V':\n        case 'v': {\n            const delta = seg.key === 'v';\n            if (seg.data.length) {\n                let y = +seg.data[0];\n                if (delta) {\n                    y += path.y;\n                }\n                ops = ops.concat(_doubleLine(path.x, path.y, path.x, y, o));\n                path.setPosition(path.x, y);\n            }\n            break;\n        }\n        case 'Z':\n        case 'z': {\n            if (path.first) {\n                ops = ops.concat(_doubleLine(path.x, path.y, path.first[0], path.first[1], o));\n                path.setPosition(path.first[0], path.first[1]);\n                path.first = null;\n            }\n            break;\n        }\n        case 'C':\n        case 'c': {\n            const delta = seg.key === 'c';\n            if (seg.data.length >= 6) {\n                let x1 = +seg.data[0];\n                let y1 = +seg.data[1];\n                let x2 = +seg.data[2];\n                let y2 = +seg.data[3];\n                let x = +seg.data[4];\n                let y = +seg.data[5];\n                if (delta) {\n                    x1 += path.x;\n                    x2 += path.x;\n                    x += path.x;\n                    y1 += path.y;\n                    y2 += path.y;\n                    y += path.y;\n                }\n                const ob = _bezierTo(x1, y1, x2, y2, x, y, path, o);\n                ops = ops.concat(ob);\n                path.bezierReflectionPoint = [x + (x - x2), y + (y - y2)];\n            }\n            break;\n        }\n        case 'S':\n        case 's': {\n            const delta = seg.key === 's';\n            if (seg.data.length >= 4) {\n                let x2 = +seg.data[0];\n                let y2 = +seg.data[1];\n                let x = +seg.data[2];\n                let y = +seg.data[3];\n                if (delta) {\n                    x2 += path.x;\n                    x += path.x;\n                    y2 += path.y;\n                    y += path.y;\n                }\n                let x1 = x2;\n                let y1 = y2;\n                const prevKey = prevSeg ? prevSeg.key : '';\n                let ref = null;\n                if (prevKey === 'c' || prevKey === 'C' || prevKey === 's' || prevKey === 'S') {\n                    ref = path.bezierReflectionPoint;\n                }\n                if (ref) {\n                    x1 = ref[0];\n                    y1 = ref[1];\n                }\n                const ob = _bezierTo(x1, y1, x2, y2, x, y, path, o);\n                ops = ops.concat(ob);\n                path.bezierReflectionPoint = [x + (x - x2), y + (y - y2)];\n            }\n            break;\n        }\n        case 'Q':\n        case 'q': {\n            const delta = seg.key === 'q';\n            if (seg.data.length >= 4) {\n                let x1 = +seg.data[0];\n                let y1 = +seg.data[1];\n                let x = +seg.data[2];\n                let y = +seg.data[3];\n                if (delta) {\n                    x1 += path.x;\n                    x += path.x;\n                    y1 += path.y;\n                    y += path.y;\n                }\n                const offset1 = 1 * (1 + o.roughness * 0.2);\n                const offset2 = 1.5 * (1 + o.roughness * 0.22);\n                ops.push({ op: 'move', data: [path.x + _offsetOpt(offset1, o), path.y + _offsetOpt(offset1, o)] });\n                let f = [x + _offsetOpt(offset1, o), y + _offsetOpt(offset1, o)];\n                ops.push({\n                    op: 'qcurveTo', data: [\n                        x1 + _offsetOpt(offset1, o), y1 + _offsetOpt(offset1, o),\n                        f[0], f[1]\n                    ]\n                });\n                ops.push({ op: 'move', data: [path.x + _offsetOpt(offset2, o), path.y + _offsetOpt(offset2, o)] });\n                f = [x + _offsetOpt(offset2, o), y + _offsetOpt(offset2, o)];\n                ops.push({\n                    op: 'qcurveTo', data: [\n                        x1 + _offsetOpt(offset2, o), y1 + _offsetOpt(offset2, o),\n                        f[0], f[1]\n                    ]\n                });\n                path.setPosition(f[0], f[1]);\n                path.quadReflectionPoint = [x + (x - x1), y + (y - y1)];\n            }\n            break;\n        }\n        case 'T':\n        case 't': {\n            const delta = seg.key === 't';\n            if (seg.data.length >= 2) {\n                let x = +seg.data[0];\n                let y = +seg.data[1];\n                if (delta) {\n                    x += path.x;\n                    y += path.y;\n                }\n                let x1 = x;\n                let y1 = y;\n                const prevKey = prevSeg ? prevSeg.key : '';\n                let ref = null;\n                if (prevKey === 'q' || prevKey === 'Q' || prevKey === 't' || prevKey === 'T') {\n                    ref = path.quadReflectionPoint;\n                }\n                if (ref) {\n                    x1 = ref[0];\n                    y1 = ref[1];\n                }\n                const offset1 = 1 * (1 + o.roughness * 0.2);\n                const offset2 = 1.5 * (1 + o.roughness * 0.22);\n                ops.push({ op: 'move', data: [path.x + _offsetOpt(offset1, o), path.y + _offsetOpt(offset1, o)] });\n                let f = [x + _offsetOpt(offset1, o), y + _offsetOpt(offset1, o)];\n                ops.push({\n                    op: 'qcurveTo', data: [\n                        x1 + _offsetOpt(offset1, o), y1 + _offsetOpt(offset1, o),\n                        f[0], f[1]\n                    ]\n                });\n                ops.push({ op: 'move', data: [path.x + _offsetOpt(offset2, o), path.y + _offsetOpt(offset2, o)] });\n                f = [x + _offsetOpt(offset2, o), y + _offsetOpt(offset2, o)];\n                ops.push({\n                    op: 'qcurveTo', data: [\n                        x1 + _offsetOpt(offset2, o), y1 + _offsetOpt(offset2, o),\n                        f[0], f[1]\n                    ]\n                });\n                path.setPosition(f[0], f[1]);\n                path.quadReflectionPoint = [x + (x - x1), y + (y - y1)];\n            }\n            break;\n        }\n        case 'A':\n        case 'a': {\n            const delta = seg.key === 'a';\n            if (seg.data.length >= 7) {\n                const rx = +seg.data[0];\n                const ry = +seg.data[1];\n                const angle = +seg.data[2];\n                const largeArcFlag = +seg.data[3];\n                const sweepFlag = +seg.data[4];\n                let x = +seg.data[5];\n                let y = +seg.data[6];\n                if (delta) {\n                    x += path.x;\n                    y += path.y;\n                }\n                if (x === path.x && y === path.y) {\n                    break;\n                }\n                if (rx === 0 || ry === 0) {\n                    ops = ops.concat(_doubleLine(path.x, path.y, x, y, o));\n                    path.setPosition(x, y);\n                }\n                else {\n                    for (let i = 0; i < 1; i++) {\n                        const arcConverter = new RoughArcConverter([path.x, path.y], [x, y], [rx, ry], angle, largeArcFlag ? true : false, sweepFlag ? true : false);\n                        let segment = arcConverter.getNextSegment();\n                        while (segment) {\n                            const ob = _bezierTo(segment.cp1[0], segment.cp1[1], segment.cp2[0], segment.cp2[1], segment.to[0], segment.to[1], path, o);\n                            ops = ops.concat(ob);\n                            segment = arcConverter.getNextSegment();\n                        }\n                    }\n                }\n            }\n            break;\n        }\n        default:\n            break;\n    }\n    return ops;\n}\n","import { SVGNS } from './core';\nimport { line, solidFillPolygon, patternFillPolygon, rectangle, ellipseWithParams, generateEllipseParams, linearPath, arc, patternFillArc, curve, svgPath } from './renderer.js';\nimport { randomSeed } from './math';\nconst hasSelf = typeof self !== 'undefined';\nconst NOS = 'none';\nexport class RoughGenerator {\n    constructor(config, surface) {\n        this.defaultOptions = {\n            maxRandomnessOffset: 2,\n            roughness: 1,\n            bowing: 1,\n            stroke: '#000',\n            strokeWidth: 1,\n            curveTightness: 0,\n            curveFitting: 0.95,\n            curveStepCount: 9,\n            fillStyle: 'hachure',\n            fillWeight: -1,\n            hachureAngle: -41,\n            hachureGap: -1,\n            dashOffset: -1,\n            dashGap: -1,\n            zigzagOffset: -1,\n            seed: 0,\n            roughnessGain: 1\n        };\n        this.config = config || {};\n        this.surface = surface;\n        if (this.config.options) {\n            this.defaultOptions = this._options(this.config.options);\n        }\n    }\n    static newSeed() {\n        return randomSeed();\n    }\n    _options(options) {\n        return options ? Object.assign({}, this.defaultOptions, options) : this.defaultOptions;\n    }\n    _drawable(shape, sets, options) {\n        return { shape, sets: sets || [], options: options || this.defaultOptions };\n    }\n    line(x1, y1, x2, y2, options) {\n        const o = this._options(options);\n        return this._drawable('line', [line(x1, y1, x2, y2, o)], o);\n    }\n    rectangle(x, y, width, height, options) {\n        const o = this._options(options);\n        const paths = [];\n        const outline = rectangle(x, y, width, height, o);\n        if (o.fill) {\n            const points = [[x, y], [x + width, y], [x + width, y + height], [x, y + height]];\n            if (o.fillStyle === 'solid') {\n                paths.push(solidFillPolygon(points, o));\n            }\n            else {\n                paths.push(patternFillPolygon(points, o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._drawable('rectangle', paths, o);\n    }\n    ellipse(x, y, width, height, options) {\n        const o = this._options(options);\n        const paths = [];\n        const ellipseParams = generateEllipseParams(width, height, o);\n        const ellipseResponse = ellipseWithParams(x, y, o, ellipseParams);\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = ellipseWithParams(x, y, o, ellipseParams).opset;\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(patternFillPolygon(ellipseResponse.estimatedPoints, o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(ellipseResponse.opset);\n        }\n        return this._drawable('ellipse', paths, o);\n    }\n    circle(x, y, diameter, options) {\n        const ret = this.ellipse(x, y, diameter, diameter, options);\n        ret.shape = 'circle';\n        return ret;\n    }\n    linearPath(points, options) {\n        const o = this._options(options);\n        return this._drawable('linearPath', [linearPath(points, false, o)], o);\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const o = this._options(options);\n        const paths = [];\n        const outline = arc(x, y, width, height, start, stop, closed, true, o);\n        if (closed && o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = arc(x, y, width, height, start, stop, true, false, o);\n                shape.type = 'fillPath';\n                paths.push(shape);\n            }\n            else {\n                paths.push(patternFillArc(x, y, width, height, start, stop, o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._drawable('arc', paths, o);\n    }\n    curve(points, options) {\n        const o = this._options(options);\n        return this._drawable('curve', [curve(points, o)], o);\n    }\n    polygon(points, options) {\n        const o = this._options(options);\n        const paths = [];\n        const outline = linearPath(points, true, o);\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                paths.push(solidFillPolygon(points, o));\n            }\n            else {\n                paths.push(patternFillPolygon(points, o));\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._drawable('polygon', paths, o);\n    }\n    path(d, options) {\n        const o = this._options(options);\n        const paths = [];\n        if (!d) {\n            return this._drawable('path', paths, o);\n        }\n        const outline = svgPath(d, o);\n        if (o.fill) {\n            if (o.fillStyle === 'solid') {\n                const shape = { type: 'path2Dfill', path: d, ops: [] };\n                paths.push(shape);\n            }\n            else {\n                const size = this.computePathSize(d);\n                const points = [\n                    [0, 0],\n                    [size[0], 0],\n                    [size[0], size[1]],\n                    [0, size[1]]\n                ];\n                const shape = patternFillPolygon(points, o);\n                shape.type = 'path2Dpattern';\n                shape.size = size;\n                shape.path = d;\n                paths.push(shape);\n            }\n        }\n        if (o.stroke !== NOS) {\n            paths.push(outline);\n        }\n        return this._drawable('path', paths, o);\n    }\n    computePathSize(d) {\n        let size = [0, 0];\n        if (hasSelf && self.document) {\n            try {\n                const svg = self.document.createElementNS(SVGNS, 'svg');\n                svg.setAttribute('width', '0');\n                svg.setAttribute('height', '0');\n                const pathNode = self.document.createElementNS(SVGNS, 'path');\n                pathNode.setAttribute('d', d);\n                svg.appendChild(pathNode);\n                self.document.body.appendChild(svg);\n                const bb = pathNode.getBBox();\n                if (bb) {\n                    size[0] = bb.width || 0;\n                    size[1] = bb.height || 0;\n                }\n                self.document.body.removeChild(svg);\n            }\n            catch (err) { }\n        }\n        const canvasSize = this.getCanvasSize();\n        if (!(size[0] * size[1])) {\n            size = canvasSize;\n        }\n        return size;\n    }\n    getCanvasSize() {\n        const val = (w) => {\n            if (w && typeof w === 'object') {\n                if (w.baseVal && w.baseVal.value) {\n                    return w.baseVal.value;\n                }\n            }\n            return w || 100;\n        };\n        if (this.surface) {\n            return [val(this.surface.width), val(this.surface.height)];\n        }\n        return [100, 100];\n    }\n    opsToPath(drawing) {\n        let path = '';\n        for (const item of drawing.ops) {\n            const data = item.data;\n            switch (item.op) {\n                case 'move':\n                    path += `M${data[0]} ${data[1]} `;\n                    break;\n                case 'bcurveTo':\n                    path += `C${data[0]} ${data[1]}, ${data[2]} ${data[3]}, ${data[4]} ${data[5]} `;\n                    break;\n                case 'qcurveTo':\n                    path += `Q${data[0]} ${data[1]}, ${data[2]} ${data[3]} `;\n                    break;\n                case 'lineTo':\n                    path += `L${data[0]} ${data[1]} `;\n                    break;\n            }\n        }\n        return path.trim();\n    }\n    toPaths(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.defaultOptions;\n        const paths = [];\n        for (const drawing of sets) {\n            let path = null;\n            switch (drawing.type) {\n                case 'path':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: o.stroke,\n                        strokeWidth: o.strokeWidth,\n                        fill: NOS\n                    };\n                    break;\n                case 'fillPath':\n                    path = {\n                        d: this.opsToPath(drawing),\n                        stroke: NOS,\n                        strokeWidth: 0,\n                        fill: o.fill || NOS\n                    };\n                    break;\n                case 'fillSketch':\n                    path = this.fillSketch(drawing, o);\n                    break;\n                case 'path2Dfill':\n                    path = {\n                        d: drawing.path || '',\n                        stroke: NOS,\n                        strokeWidth: 0,\n                        fill: o.fill || NOS\n                    };\n                    break;\n                case 'path2Dpattern': {\n                    const size = drawing.size;\n                    const pattern = {\n                        x: 0, y: 0, width: 1, height: 1,\n                        viewBox: `0 0 ${Math.round(size[0])} ${Math.round(size[1])}`,\n                        patternUnits: 'objectBoundingBox',\n                        path: this.fillSketch(drawing, o)\n                    };\n                    path = {\n                        d: drawing.path,\n                        stroke: NOS,\n                        strokeWidth: 0,\n                        pattern: pattern\n                    };\n                    break;\n                }\n            }\n            if (path) {\n                paths.push(path);\n            }\n        }\n        return paths;\n    }\n    fillSketch(drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        return {\n            d: this.opsToPath(drawing),\n            stroke: o.fill || NOS,\n            strokeWidth: fweight,\n            fill: NOS\n        };\n    }\n}\n","import { SVGNS } from './core';\nimport { RoughGenerator } from './generator';\nconst hasDocument = typeof document !== 'undefined';\nexport class RoughCanvas {\n    constructor(canvas, config) {\n        this.canvas = canvas;\n        this.ctx = this.canvas.getContext('2d');\n        this.gen = new RoughGenerator(config, this.canvas);\n    }\n    draw(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.getDefaultOptions();\n        const ctx = this.ctx;\n        for (const drawing of sets) {\n            switch (drawing.type) {\n                case 'path':\n                    ctx.save();\n                    ctx.strokeStyle = o.stroke === 'none' ? 'transparent' : o.stroke;\n                    ctx.lineWidth = o.strokeWidth;\n                    this._drawToContext(ctx, drawing);\n                    ctx.restore();\n                    break;\n                case 'fillPath':\n                    ctx.save();\n                    ctx.fillStyle = o.fill || '';\n                    this._drawToContext(ctx, drawing);\n                    ctx.restore();\n                    break;\n                case 'fillSketch':\n                    this.fillSketch(ctx, drawing, o);\n                    break;\n                case 'path2Dfill': {\n                    this.ctx.save();\n                    this.ctx.fillStyle = o.fill || '';\n                    const p2d = new Path2D(drawing.path);\n                    this.ctx.fill(p2d);\n                    this.ctx.restore();\n                    break;\n                }\n                case 'path2Dpattern': {\n                    const doc = this.canvas.ownerDocument || (hasDocument && document);\n                    if (doc) {\n                        const size = drawing.size;\n                        const hcanvas = doc.createElement('canvas');\n                        const hcontext = hcanvas.getContext('2d');\n                        const bbox = this.computeBBox(drawing.path);\n                        if (bbox && (bbox.width || bbox.height)) {\n                            hcanvas.width = this.canvas.width;\n                            hcanvas.height = this.canvas.height;\n                            hcontext.translate(bbox.x || 0, bbox.y || 0);\n                        }\n                        else {\n                            hcanvas.width = size[0];\n                            hcanvas.height = size[1];\n                        }\n                        this.fillSketch(hcontext, drawing, o);\n                        this.ctx.save();\n                        this.ctx.fillStyle = this.ctx.createPattern(hcanvas, 'repeat');\n                        const p2d = new Path2D(drawing.path);\n                        this.ctx.fill(p2d);\n                        this.ctx.restore();\n                    }\n                    else {\n                        console.error('Pattern fill fail: No defs');\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    computeBBox(d) {\n        if (hasDocument) {\n            try {\n                const svg = document.createElementNS(SVGNS, 'svg');\n                svg.setAttribute('width', '0');\n                svg.setAttribute('height', '0');\n                const pathNode = self.document.createElementNS(SVGNS, 'path');\n                pathNode.setAttribute('d', d);\n                svg.appendChild(pathNode);\n                document.body.appendChild(svg);\n                const bbox = pathNode.getBBox();\n                document.body.removeChild(svg);\n                return bbox;\n            }\n            catch (err) { }\n        }\n        return null;\n    }\n    fillSketch(ctx, drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        ctx.save();\n        ctx.strokeStyle = o.fill || '';\n        ctx.lineWidth = fweight;\n        this._drawToContext(ctx, drawing);\n        ctx.restore();\n    }\n    _drawToContext(ctx, drawing) {\n        ctx.beginPath();\n        for (const item of drawing.ops) {\n            const data = item.data;\n            switch (item.op) {\n                case 'move':\n                    ctx.moveTo(data[0], data[1]);\n                    break;\n                case 'bcurveTo':\n                    ctx.bezierCurveTo(data[0], data[1], data[2], data[3], data[4], data[5]);\n                    break;\n                case 'qcurveTo':\n                    ctx.quadraticCurveTo(data[0], data[1], data[2], data[3]);\n                    break;\n                case 'lineTo':\n                    ctx.lineTo(data[0], data[1]);\n                    break;\n            }\n        }\n        if (drawing.type === 'fillPath') {\n            ctx.fill();\n        }\n        else {\n            ctx.stroke();\n        }\n    }\n    get generator() {\n        return this.gen;\n    }\n    getDefaultOptions() {\n        return this.gen.defaultOptions;\n    }\n    line(x1, y1, x2, y2, options) {\n        const d = this.gen.line(x1, y1, x2, y2, options);\n        this.draw(d);\n        return d;\n    }\n    rectangle(x, y, width, height, options) {\n        const d = this.gen.rectangle(x, y, width, height, options);\n        this.draw(d);\n        return d;\n    }\n    ellipse(x, y, width, height, options) {\n        const d = this.gen.ellipse(x, y, width, height, options);\n        this.draw(d);\n        return d;\n    }\n    circle(x, y, diameter, options) {\n        const d = this.gen.circle(x, y, diameter, options);\n        this.draw(d);\n        return d;\n    }\n    linearPath(points, options) {\n        const d = this.gen.linearPath(points, options);\n        this.draw(d);\n        return d;\n    }\n    polygon(points, options) {\n        const d = this.gen.polygon(points, options);\n        this.draw(d);\n        return d;\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const d = this.gen.arc(x, y, width, height, start, stop, closed, options);\n        this.draw(d);\n        return d;\n    }\n    curve(points, options) {\n        const d = this.gen.curve(points, options);\n        this.draw(d);\n        return d;\n    }\n    path(d, options) {\n        const drawing = this.gen.path(d, options);\n        this.draw(drawing);\n        return drawing;\n    }\n}\n","import { SVGNS } from './core';\nimport { RoughGenerator } from './generator';\nconst hasDocument = typeof document !== 'undefined';\nexport class RoughSVG {\n    constructor(svg, config) {\n        this.svg = svg;\n        this.gen = new RoughGenerator(config, this.svg);\n    }\n    get defs() {\n        const doc = this.svg.ownerDocument || (hasDocument && document);\n        if (doc) {\n            if (!this._defs) {\n                const dnode = doc.createElementNS(SVGNS, 'defs');\n                if (this.svg.firstChild) {\n                    this.svg.insertBefore(dnode, this.svg.firstChild);\n                }\n                else {\n                    this.svg.appendChild(dnode);\n                }\n                this._defs = dnode;\n            }\n        }\n        return this._defs || null;\n    }\n    draw(drawable) {\n        const sets = drawable.sets || [];\n        const o = drawable.options || this.getDefaultOptions();\n        const doc = this.svg.ownerDocument || window.document;\n        const g = doc.createElementNS(SVGNS, 'g');\n        for (const drawing of sets) {\n            let path = null;\n            switch (drawing.type) {\n                case 'path': {\n                    path = doc.createElementNS(SVGNS, 'path');\n                    path.setAttribute('d', this.opsToPath(drawing));\n                    path.style.stroke = o.stroke;\n                    path.style.strokeWidth = o.strokeWidth + '';\n                    path.style.fill = 'none';\n                    break;\n                }\n                case 'fillPath': {\n                    path = doc.createElementNS(SVGNS, 'path');\n                    path.setAttribute('d', this.opsToPath(drawing));\n                    path.style.stroke = 'none';\n                    path.style.strokeWidth = '0';\n                    path.style.fill = o.fill || '';\n                    break;\n                }\n                case 'fillSketch': {\n                    path = this.fillSketch(doc, drawing, o);\n                    break;\n                }\n                case 'path2Dfill': {\n                    path = doc.createElementNS(SVGNS, 'path');\n                    path.setAttribute('d', drawing.path || '');\n                    path.style.stroke = 'none';\n                    path.style.strokeWidth = '0';\n                    path.style.fill = o.fill || '';\n                    break;\n                }\n                case 'path2Dpattern': {\n                    if (!this.defs) {\n                        console.error('Pattern fill fail: No defs');\n                    }\n                    else {\n                        const size = drawing.size;\n                        const pattern = doc.createElementNS(SVGNS, 'pattern');\n                        const id = `rough-${Math.floor(Math.random() * (Number.MAX_SAFE_INTEGER || 999999))}`;\n                        pattern.setAttribute('id', id);\n                        pattern.setAttribute('x', '0');\n                        pattern.setAttribute('y', '0');\n                        pattern.setAttribute('width', '1');\n                        pattern.setAttribute('height', '1');\n                        pattern.setAttribute('height', '1');\n                        pattern.setAttribute('viewBox', `0 0 ${Math.round(size[0])} ${Math.round(size[1])}`);\n                        pattern.setAttribute('patternUnits', 'objectBoundingBox');\n                        const patternPath = this.fillSketch(doc, drawing, o);\n                        pattern.appendChild(patternPath);\n                        this.defs.appendChild(pattern);\n                        path = doc.createElementNS(SVGNS, 'path');\n                        path.setAttribute('d', drawing.path || '');\n                        path.style.stroke = 'none';\n                        path.style.strokeWidth = '0';\n                        path.style.fill = `url(#${id})`;\n                    }\n                    break;\n                }\n            }\n            if (path) {\n                g.appendChild(path);\n            }\n        }\n        return g;\n    }\n    fillSketch(doc, drawing, o) {\n        let fweight = o.fillWeight;\n        if (fweight < 0) {\n            fweight = o.strokeWidth / 2;\n        }\n        const path = doc.createElementNS(SVGNS, 'path');\n        path.setAttribute('d', this.opsToPath(drawing));\n        path.style.stroke = o.fill || '';\n        path.style.strokeWidth = fweight + '';\n        path.style.fill = 'none';\n        return path;\n    }\n    get generator() {\n        return this.gen;\n    }\n    getDefaultOptions() {\n        return this.gen.defaultOptions;\n    }\n    opsToPath(drawing) {\n        return this.gen.opsToPath(drawing);\n    }\n    line(x1, y1, x2, y2, options) {\n        const d = this.gen.line(x1, y1, x2, y2, options);\n        return this.draw(d);\n    }\n    rectangle(x, y, width, height, options) {\n        const d = this.gen.rectangle(x, y, width, height, options);\n        return this.draw(d);\n    }\n    ellipse(x, y, width, height, options) {\n        const d = this.gen.ellipse(x, y, width, height, options);\n        return this.draw(d);\n    }\n    circle(x, y, diameter, options) {\n        const d = this.gen.circle(x, y, diameter, options);\n        return this.draw(d);\n    }\n    linearPath(points, options) {\n        const d = this.gen.linearPath(points, options);\n        return this.draw(d);\n    }\n    polygon(points, options) {\n        const d = this.gen.polygon(points, options);\n        return this.draw(d);\n    }\n    arc(x, y, width, height, start, stop, closed = false, options) {\n        const d = this.gen.arc(x, y, width, height, start, stop, closed, options);\n        return this.draw(d);\n    }\n    curve(points, options) {\n        const d = this.gen.curve(points, options);\n        return this.draw(d);\n    }\n    path(d, options) {\n        const drawing = this.gen.path(d, options);\n        return this.draw(drawing);\n    }\n}\n","import { RoughCanvas } from './canvas';\nimport { RoughGenerator } from './generator';\nimport { RoughSVG } from './svg';\nexport default {\n    canvas(canvas, config) {\n        return new RoughCanvas(canvas, config);\n    },\n    svg(svg, config) {\n        return new RoughSVG(svg, config);\n    },\n    generator(config, surface) {\n        return new RoughGenerator(config, surface);\n    },\n    newSeed() {\n        return RoughGenerator.newSeed();\n    }\n};\n","export const canvas = document.getElementById('canvas')\nexport const winnerElement = document.getElementById('winner')\nexport const resetElement = document.getElementById('reset')\nexport const ctx = canvas.getContext('2d')\nexport const width = canvas.width\nexport const height = canvas.height\n","import rough from 'roughjs/bin/rough'\nimport { canvas, ctx, width, height } from './elements'\n\nconst rc = rough.canvas(canvas)\nconst margin = 32\n\nfunction drawGridLine(x1, y1, x2, y2) {\n  rc.line(x1, y1,\n          x2, y2,\n          { strokeWidth: 15,\n            roughness: 3,\n            stroke: 'rgb(249, 200, 14)' })\n}\n\nfunction drawGrid() {\n  // Vertical lines\n  drawGridLine(width * 0.33, margin,\n               width * 0.33, height - margin)\n  drawGridLine(width * 0.66, margin,\n              width * 0.66, height - margin)\n  // Horizontal lines\n  drawGridLine(margin, height * 0.33,\n               width - margin, height * 0.33)\n  drawGridLine(margin, height * 0.66,\n               width - margin, height * 0.66)\n}\n\nfunction drawX(index) {\n  const row = index % 3\n  const col = Math.floor(index / 3)\n  const x1 = (margin *  1.5) + row * (width / 3)\n  const y1 = (margin *  1.5) + col * (height / 3)\n  const x2 = (margin * -3) + x1  + width / 3\n  const y2 = (margin * -3) + y1  + height / 3\n  rc.line(x1, y1,\n          x2, y2,\n          { strokeWidth: 15,\n            roughness: 3,\n            stroke: 'rgb(204, 0, 53' })\n  rc.line(x2, y1,\n          x1, y2,\n          { strokeWidth: 15,\n            roughness: 3,\n            stroke: 'rgb(204, 0, 53' })\n}\n\nfunction drawO(index) {\n  const row = index % 3\n  const col = Math.floor(index / 3)\n  const x1 = (margin *  1.5) + row * (width / 3)\n  const y1 = (margin *  1.5) + col * (height / 3)\n  const x2 = (margin * -3) + x1  + width / 3\n  const y2 = (margin * -3) + y1  + height / 3\n  const xmid = (x1 + x2) / 2\n  const ymid = (y1 + y2) / 2\n  rc.ellipse(xmid, ymid,\n             (width - margin * 7.5) / 3,\n             (height - margin * 5.5) / 3,\n             { strokeWidth: 15,\n               roughness: 1,\n               stroke: 'rgb(53, 76, 161)' })\n}\n\nexport function redraw(board) {\n  ctx.clearRect(0, 0, canvas.width, canvas.height)\n  drawGrid()\n  for (let i = 0; i < 9; i++) {\n    if (board[i] === 1) {\n      drawX(i)\n    } else if (board[i] === -1) {\n      drawO(i)\n    }\n  }\n}\n","import { redraw } from './draw'\nimport { canvas, winnerElement, resetElement, width, height } from './elements'\n\nconst serviceLocation = location.hostname === 'localhost'\n                        ? 'http://localhost:8000/tic-tac-toe-AI'\n                        : 'https://fatdog.herokuapp.com/tic-tac-toe-AI'\n\nlet waitingForAi = false\n\n// Main state\nlet board = null // structure should match server-side\nlet winner = null\n\ncanvas.addEventListener('click', (e) => {\n  if (winner) return // Cannot click if game is already over\n  if (waitingForAi) return // Cannot click while AI's turn\n  const rect = canvas.getBoundingClientRect()\n  const x = Math.floor((e.clientX - rect.left) / (width * 0.33))\n  const y = Math.floor((e.clientY - rect.top) / (height * 0.33))\n  const index = y * 3 + x\n  if (board[index] === 0) {\n    board[index] = -1\n    redraw(board)\n    advance()\n  }\n})\n\nresetElement.addEventListener('click', (e) => {\n  reset()\n})\n\n// TODO: journal key for requests, to prevent async issues\n//       - render in-order\n//       - discard input when request is active\n// TODO: error handling\n// TODO: Pick random 1s\n\n/**\n * Used by advance() only\n */\nfunction startWaitingForAi() {\n  if (waitingForAi) return false // already waiting\n  waitingForAi = true\n  canvas.classList.add('translucent')\n  document.body.classList.add('wait')\n  return true\n}\n\n/**\n * Used by advance() only\n */\nfunction stopWaitingForAi() {\n  waitingForAi = false\n  canvas.classList.remove('translucent')\n  document.body.classList.remove('wait')\n}\n\n/**\n * Expects -1, 0, 1, or false\n */\nfunction handleWinner(given) {\n  winner = given\n  if (winner !== false) {\n    let message\n    if (winner === 1) {\n      message = 'X Wins'\n    } else if (winner === -1) {\n      message = 'O Wins' // Should never happen\n    } else if (winner === null) {\n      message = 'Tie'\n    }\n    winnerElement.classList.remove('invisible')\n    winnerElement.textContent = message\n    resetElement.classList.remove('invisible')\n  } else {\n    winnerElement.classList.add('invisible')\n    winnerElement.textContent = ''\n    resetElement.classList.add('invisible')\n  }\n}\n\nfunction advance() {\n  const payload = { board }\n  if (!startWaitingForAi()) return // one request at a time\n  fetch(`${serviceLocation}`, {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json'\n    },\n    body: JSON.stringify(payload)\n  }).then((response) => {\n    return response.json()\n  }).then((state) => {\n    board = state['board']\n    handleWinner(state['winner'])\n    redraw(board)\n  }).catch((e) => {\n    console.error('HMMMMM', e)\n  }).finally(() => {\n    stopWaitingForAi()\n  })\n}\n\nfunction reset() {\n  board = [0, 0, 0, 0, 0, 0, 0, 0, 0] // structure should match server-side\n  winner = false\n  redraw(board)\n  advance()\n}\n\n// Begin\nreset()\n"]}